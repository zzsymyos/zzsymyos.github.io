<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>AQS源码解析 | 兔子临死前</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.3"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-159147438-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'f6b53e381450eb6439f074e9a0eb6fb4';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">AQS源码解析</h1><a id="logo" href="/.">兔子临死前</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">AQS源码解析</h1><div class="post-meta">Feb 29, 2020<span> | </span><span class="category"><a href="/categories/JDK%E6%BA%90%E7%A0%81/">JDK源码</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 16</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、CAS原理"><span class="toc-number">1.</span> <span class="toc-text">一、CAS原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、简介"><span class="toc-number">1.1.</span> <span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、问题"><span class="toc-number">1.2.</span> <span class="toc-text">2、问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、ABA问题"><span class="toc-number">1.2.1.</span> <span class="toc-text">a、ABA问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、性能问题"><span class="toc-number">1.2.2.</span> <span class="toc-text">b、性能问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、锁"><span class="toc-number">2.</span> <span class="toc-text">二、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、锁的类型"><span class="toc-number">2.1.</span> <span class="toc-text">1、锁的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-乐观锁-悲观锁"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 乐观锁&#x2F;悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-独享锁-共享锁"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 独享锁&#x2F;共享锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-互斥锁-读写锁"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 互斥锁&#x2F;读写锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-可重入锁"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-公平锁-非公平锁"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5 公平锁&#x2F;非公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-分段锁"><span class="toc-number">2.1.6.</span> <span class="toc-text">1.6 分段锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-偏向锁-轻量级锁-重量级锁"><span class="toc-number">2.1.7.</span> <span class="toc-text">1.7 偏向锁&#x2F;轻量级锁&#x2F;重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-自旋锁"><span class="toc-number">2.1.8.</span> <span class="toc-text">1.8 自旋锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、AQS解析"><span class="toc-number">3.</span> <span class="toc-text">三、AQS解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、前置资料"><span class="toc-number">3.1.</span> <span class="toc-text">1、前置资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、ReentrantLock"><span class="toc-number">3.2.</span> <span class="toc-text">2、ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-NonfairSync-lock"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 NonfairSync.lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-AbstractQueuedSynchronizer-acquire"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 AbstractQueuedSynchronizer.acquire</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-NonfairSync-tryAcquire"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 NonfairSync.tryAcquire</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-AbstractQueuedSynchronizer-addWaiter"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4 AbstractQueuedSynchronizer.addWaiter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-AbstractQueuedSynchronizer-enq"><span class="toc-number">3.2.5.</span> <span class="toc-text">2.5 AbstractQueuedSynchronizer.enq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-AbstractQueuedSynchronizer-acquireQueued"><span class="toc-number">3.2.6.</span> <span class="toc-text">2.6 AbstractQueuedSynchronizer.acquireQueued</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-AbstractQueuedSynchronizer-shouldParkAfterFailedAcquire"><span class="toc-number">3.2.7.</span> <span class="toc-text">2.7 AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-Sync-tryrelease"><span class="toc-number">3.2.8.</span> <span class="toc-text">2.7 Sync.tryrelease</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-AbstractQueuedSynchronizer-unparkSuccessor"><span class="toc-number">3.2.9.</span> <span class="toc-text">2.8 AbstractQueuedSynchronizer.unparkSuccessor</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><style>
table tr th,td {
    border: 1px solid #000;
}
</style>
<h2 id="一、CAS原理"><a href="#一、CAS原理" class="headerlink" title="一、CAS原理"></a>一、CAS原理</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>　　CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。CAS 操作包含三个操作数 – 内存位置、预期数值和新值。<br>　　CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。<br>具体实现，<br>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);<br>这个是一个native方法， 第一个参数为需要改变的对象，第二个为偏移量(即之前求出来的headOffset的值)，第三个参数为期待的值，第四个为更新后的值<br>整个方法的作用是如果当前时刻的值等于预期值var4相等，则更新为新的期望值 var5，如果更新成功，则返回true，否则返回false；</p>
<p>Unsafe<br>　　Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Hadoop、Kafka等；<br>Unsafe可认为是Java中留下的后门，提供了一些低层次操作，如直接内存访问、线程调度等</p>
<h3 id="2、问题"><a href="#2、问题" class="headerlink" title="2、问题"></a>2、问题</h3><h4 id="a、ABA问题"><a href="#a、ABA问题" class="headerlink" title="a、ABA问题"></a>a、ABA问题</h4><p>　　就是要维护的变量被替换后，又设置回来。类实例将无法辨别它被替换过。 举个例子，假设有一个变量x：<br>线程1试图用cas把x从A设置为C，所以它先查询x的值。(在这瞬间，线程切换)<br>线程2用cas把x设置为B<br>线程2用cas把x设置为A<br>(线程切换回来)线程1查询到x的值为A，于是cas理所当然地把x改为了C。<br>问题是：线程1在查询x的过程中，x的值已经经历了A-&gt;B→A的转变，而线程1对此无所知。这就是ABA问题了。</p>
<p>解决方案：<br>　　对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。AtomicStampedReference类便是使用版本号来解决ABA问题的。<br>　　AtomicStampedReference原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境。</p>
<h4 id="b、性能问题"><a href="#b、性能问题" class="headerlink" title="b、性能问题"></a>b、性能问题</h4><p>　　我们使用时大部分时间使用的是 while true 方式对数据的修改，直到成功为止。优势就是相应极快，但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。</p>
<h2 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h2><h3 id="1、锁的类型"><a href="#1、锁的类型" class="headerlink" title="1、锁的类型"></a>1、锁的类型</h3><p>锁从宏观上分类，分为悲观锁与乐观锁。重量级锁是悲观锁的一种，自旋锁、轻量级锁与偏向锁属于乐观锁</p>
<h4 id="1-1-乐观锁-悲观锁"><a href="#1-1-乐观锁-悲观锁" class="headerlink" title="1.1 乐观锁/悲观锁"></a>1.1 乐观锁/悲观锁</h4><p>　　乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。<br>　　java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。<br>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p>
<h4 id="1-2-独享锁-共享锁"><a href="#1-2-独享锁-共享锁" class="headerlink" title="1.2 独享锁/共享锁"></a>1.2 独享锁/共享锁</h4><p>　　独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。<br>　　对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。<br>　　读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。<br>　　独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。对于Synchronized而言，当然是独享锁。</p>
<h4 id="1-3-互斥锁-读写锁"><a href="#1-3-互斥锁-读写锁" class="headerlink" title="1.3 互斥锁/读写锁"></a>1.3 互斥锁/读写锁</h4><p>　　上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。<br>　　互斥锁在Java中的具体实现就是ReentrantLock。读写锁在Java中的具体实现就是ReadWriteLock。</p>
<h4 id="1-4-可重入锁"><a href="#1-4-可重入锁" class="headerlink" title="1.4 可重入锁"></a>1.4 可重入锁</h4><p>　　可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。<br>　　对于Java ReetrantLock而言，从名字就可以看出是一个重入锁，其名字是Re entrant Lock 重新进入锁。<br>　　对于Synchronized而言，也是一个可重入锁。<font color='red'>可重入锁的一个好处是可一定程度避免死锁。</font></p>
<h4 id="1-5-公平锁-非公平锁"><a href="#1-5-公平锁-非公平锁" class="headerlink" title="1.5 公平锁/非公平锁"></a>1.5 公平锁/非公平锁</h4><p>　　公平锁是指多个线程按照申请锁的顺序来获取锁。<br>　　非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br>　　对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>　　对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p>
<h4 id="1-6-分段锁"><a href="#1-6-分段锁" class="headerlink" title="1.6 分段锁"></a>1.6 分段锁</h4><p>　　分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。<br>　　我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock<font color='red'>（Segment继承了ReentrantLock）</font>。<br>　　当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>　　但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。<br>　　分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p>
<h4 id="1-7-偏向锁-轻量级锁-重量级锁"><a href="#1-7-偏向锁-轻量级锁-重量级锁" class="headerlink" title="1.7 偏向锁/轻量级锁/重量级锁"></a>1.7 偏向锁/轻量级锁/重量级锁</h4><p>　　这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。<br>　　偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。<br>　　轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>　　重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。</p>
<p>各种锁的优缺点及适用场景</p>
<table>
<thead>
<tr>
<th align="left">锁</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">偏向锁</td>
<td align="left">加锁和解锁不需要额外的消耗，与执行非同步方法仅存在纳秒级的差距</td>
<td align="left">如果线程间存在竞争，会带来额外的锁撤销的消耗</td>
<td align="left">适用于只有一个线程访问同步块的情况</td>
</tr>
<tr>
<td align="left">轻量级锁</td>
<td align="left">竞争的线程不会堵塞，提高了程序的响应速度</td>
<td align="left">始终得不到锁的线程，使用自旋会消耗CPU</td>
<td align="left">追求响应时间，同步块执行速度非常块，只有两个线程竞争锁</td>
</tr>
<tr>
<td align="left">重量级锁</td>
<td align="left">线程竞争不使用自旋，不会消耗CPU</td>
<td align="left">线程堵塞，响应时间缓慢</td>
<td align="left">追求吞吐量，同步块执行速度比较慢，竞争锁的线程大于2个</td>
</tr>
</tbody></table>
<h4 id="1-8-自旋锁"><a href="#1-8-自旋锁" class="headerlink" title="1.8 自旋锁"></a>1.8 自旋锁</h4><p>　　在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
<h2 id="三、AQS解析"><a href="#三、AQS解析" class="headerlink" title="三、AQS解析"></a>三、AQS解析</h2><h3 id="1、前置资料"><a href="#1、前置资料" class="headerlink" title="1、前置资料"></a>1、前置资料</h3><p>当state=0时，表示无锁状态<br>当state&gt;0时，表示已经有线程获得了锁，也就是state=1，但是因为ReentrantLock允许重入，所以同一个线程多次获得同步锁的时候，state会递增，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁，<br>AQS的Node中有每个Node自己的状态（waitStatus）：<br>SIGNAL(-1) ：前面有线程在运行，需要前面线程结束后，调用unpark()方法才能激活自己<br>CANCELLED(1)：因为超时或中断，该线程已经被取消<br>CONDITION(-2)：表明该线程被处于条件队列，就是因为调用了&gt;- Condition.await而被阻塞<br>PROPAGATE(-3)：传播共享锁</p>
<h3 id="2、ReentrantLock"><a href="#2、ReentrantLock" class="headerlink" title="2、ReentrantLock"></a>2、ReentrantLock</h3><p>Sync这个类有两个具体的实现，分别是NofairSync(非公平锁),FailSync(公平锁).<br>ReentrantLock 主要是基于非公平锁的独占锁实现。在获得同步锁时，同步器维护一个FIFO双向同步（CLH）队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；</p>
<p>移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</p>
<h4 id="2-1-NonfairSync-lock"><a href="#2-1-NonfairSync-lock" class="headerlink" title="2.1 NonfairSync.lock"></a>2.1 NonfairSync.lock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">//通过cas操作来修改state状态，表示争抢锁的操作</span></span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置当前获得锁状态的线程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      acquire(<span class="number">1</span>); <span class="comment">//尝试去获取锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-AbstractQueuedSynchronizer-acquire"><a href="#2-2-AbstractQueuedSynchronizer-acquire" class="headerlink" title="2.2 AbstractQueuedSynchronizer.acquire"></a>2.2 AbstractQueuedSynchronizer.acquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  <span class="comment">//通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="comment">//如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部</span></span><br><span class="line">                                                            <span class="comment">//acquireQueued Node作为参数，通过自旋去尝试获取锁</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-NonfairSync-tryAcquire"><a href="#2-3-NonfairSync-tryAcquire" class="headerlink" title="2.3 NonfairSync.tryAcquire"></a>2.3 NonfairSync.tryAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//state=0说明当前是无锁状态</span></span><br><span class="line">        <span class="comment">//通过cas操作来替换state的值改为1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             <span class="comment">//保存当前获得锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是同一个线程来获得锁，则直接增加重入次数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">//增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-AbstractQueuedSynchronizer-addWaiter"><a href="#2-4-AbstractQueuedSynchronizer-addWaiter" class="headerlink" title="2.4 AbstractQueuedSynchronizer.addWaiter"></a>2.4 AbstractQueuedSynchronizer.addWaiter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">//mode=Node.EXCLUSIVE</span></span><br><span class="line">        <span class="comment">//将当前线程封装成Node，并且mode为独占锁</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// tail是AQS的中表示同步队列队尾的属性，刚开始为null，所以进行enq(node)方法</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//tail不为空的情况，说明队列中存在节点数据</span></span><br><span class="line">            node.prev = pred;  <span class="comment">//1.将当前线程的Node的prev节点指向tail </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//2.通过cas讲node添加到AQS队列</span></span><br><span class="line">                pred.next = node;<span class="comment">//3.cas成功，把旧的tail的next指针指向新的tail</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node); <span class="comment">//tail=null，将node添加到同步队列中</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-AbstractQueuedSynchronizer-enq"><a href="#2-5-AbstractQueuedSynchronizer-enq" class="headerlink" title="2.5 AbstractQueuedSynchronizer.enq"></a>2.5 AbstractQueuedSynchronizer.enq</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail; <span class="comment">//如果是第一次添加到队列，那么tail=null</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//CAS的方式创建一个空的Node作为头结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   <span class="comment">//此时队列中只一个头结点，所以tail也指向它</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                node.prev = t;<span class="comment">//1. 进行第二次循环时，tail不为null。将当前线程的Node结点的prev指向tail，然后使用CAS将tail指向Node</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  <span class="comment">//2. t此时指向tail,所以可以CAS成功，将tail重新指向Node。此时t为更新前的tail的值，即指向空的头结点</span></span><br><span class="line">                    t.next = node; <span class="comment">//3. t目前指向了头结点，将头结点的后续结点指向Node，返回头结点</span></span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-AbstractQueuedSynchronizer-acquireQueued"><a href="#2-6-AbstractQueuedSynchronizer-acquireQueued" class="headerlink" title="2.6 AbstractQueuedSynchronizer.acquireQueued"></a>2.6 AbstractQueuedSynchronizer.acquireQueued</h4><p>将添加到队列中的Node作为参数传入acquireQueued方法，这里面会做抢占锁的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">// 获取prev节点,若为null即刻抛出NullPointException</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 如果前驱为head才有资格进行锁的抢夺</span></span><br><span class="line">                setHead(node); <span class="comment">// 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点</span></span><br><span class="line">                <span class="comment">//凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC 移除原来的初始化head节点</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">//获取锁成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">// 阻塞操作，正常情况下，获取不到锁，代码就在该方法停止了，直到被唤醒</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果抛出异常则取消锁的获取,进行出队(sync queue)操作</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-AbstractQueuedSynchronizer-shouldParkAfterFailedAcquire"><a href="#2-7-AbstractQueuedSynchronizer-shouldParkAfterFailedAcquire" class="headerlink" title="2.7 AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire"></a>2.7 AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire</h4><p>  靠前继节点判断当前线程是否应该被阻塞，如果前继节点处于CANCELLED状态，则顺便删除这些节点重新构造队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">//前继节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//如果是SIGNAL状态，意味着当前线程需要被park</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">如果前节点的状态大于<span class="number">0</span>，即为CANCELLED状态时，则会从前节点开始逐步循环找到一个没有被“CANCELLED”节点设置为当前节点的前节点，返回<span class="keyword">false</span>。在下次循环执行shouldParkAfterFailedAcquire时，返回<span class="keyword">true</span>。这个操作实际是把队列中CANCELLED的节点剔除掉。</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点” 为 “‘原前继节点'的前继节点”。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-Sync-tryrelease"><a href="#2-7-Sync-tryrelease" class="headerlink" title="2.7 Sync.tryrelease"></a>2.7 Sync.tryrelease</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 这里是将锁的数量减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 由于重入的关系，不是每次释放锁c都等于0,直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-8-AbstractQueuedSynchronizer-unparkSuccessor"><a href="#2-8-AbstractQueuedSynchronizer-unparkSuccessor" class="headerlink" title="2.8 AbstractQueuedSynchronizer.unparkSuccessor"></a>2.8 AbstractQueuedSynchronizer.unparkSuccessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//判断后继节点是否为空或者是否是取消状态,</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点,为什么向前遍历？</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简要总结一下AQS的流程的一些特性：<br>    • 关键获取锁、释放锁操作由AQS子类实现：acquire-release、acquireShared-releaseShared；<br>    • 维护了一个FIFO链表结构的队列，通过自旋方式将新结点添加到队尾；<br>    • 添加结点时会从前驱结点向前遍历，跳过那些处于CANCELLED状态的结点；<br>    • 释放结点时会从队尾向前遍历，踢出CANCELLED状态的结点，然后唤醒后继结点；</p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=https://github.com/Kaiyuan/donate-page## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page&amp;BTCQR=undefined&amp;BTCKEY=undefined&amp;PayPal=undefined" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.3" async></script><a class="article-share-link" data-url="http://yoursite.com/2020/02/29/%E6%8A%80%E6%9C%AF/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/jdk%E6%BA%90%E7%A0%81/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" data-id="ck77g20490000jvcbhs6a3dh8" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEkElEQVR42u3aS27bQBAFQN//0gmQVYCE8nvddKKhiytBtsiZ4mL69/ERXz9+Xa8///7N6+vP/7y6w9UaXq/waiXJfVYXJkyYMGF6S6Z8SzniXdcGaL9aTJgwYcL0JKb2dvnhGi0iDj6SMCIJWfK9Y8KECROm78P0eul5+prDtWlz/rIxYcKECROm/DDOl9Vusj3CX4NiwoQJE6bvzJS3Htu0M2lP5q8h33yeut9cC8eECRMmTG/GdNfgzomf/8N8EyZMmDBh+odMszGaWQqajNq8Tk3bJLYtMV/eHxMmTJgwHcuUP2A2RtM2EXPQPUS9NkyYMGHCdCDTrE2YHNuzkaB86S1E0l69/IwJEyZMmI5lalPWWbK6uc+sVZkn3m2KjgkTJkyYzmLKD+N88+3hvQ9BZml8EgpgwoQJE6bTmWZJ6euNze5zbzE3L0Mnf8WECRMmTOcyzcZf9pv56vLuJqy5HNnBhAkTJkwPZdqUVjeDPvvENf9VVOTFhAkTJkzHMm0S4HsT1H1j9S6yvwQEmDBhwoTpWKZiuuflr5KFtrXnvBX6FS8MEyZMmDCdzpRj5QvNsdpAZNakrDu6V0/HhAkTJkwHMrWHYtv+bJuXOUpbdG5fISZMmDBhegZT/oC2ILta0Mv4ZZYMb0aFMGHChAnTs5lmx/xHfM2O8HYwqH15nyTAmDBhwoTpEKZZ2tkese3dWqbkpc6CBkyYMGHC9CSmJBHNm5HJYZyHDnmA0q4qegomTJgwYXooU1LqbY//9vuEOG++5mEEJkyYMGF6BlN+8LejPHlDdFY4bu/TBhNFqRoTJkyYML0xU76l2cjLLBluEfMwZbYvTJgwYcJ0OlMbLyRLuSsqmRWd2+GhTwIdTJgwYcJ0LFPeLJwNnuaF3WTDm1CgHfEZ9lQxYcKECdObMeU/mH3OW49t87Jded4i/cvKMWHChAnT4UxJ+rov4OaLmwUWyYaHoQkmTJgwYTqWaVY2/erHt43VfYl5WBTGhAkTJkxvz5QUQ2fjO5tjuy0Nz0rGRbMWEyZMmDAdzpSkqXkynJdcZ9FK27bcjBlhwoQJE6bnMW3Kte1mcsr8PsnrbIMSTJgwYcJ0LtNsY/vxnWS5+YbbVLwtUmPChAkTptOZZgdtPtaTbztPaGcrydN4TJgwYcL0DKb8OJxFGW1SvW9htmXiaLWYMGHChOmhTElTM093Z9+0988bsUUogwkTJkyYDmeajdTM0s48I2/vdtdvL1NfTJgwYcJ0ONMmJW4TziQsyFPou17A5R0wYcKECdOxTPlmPumIlte+LNsGBy30J7/ChAkTJkyHMG0GN/OwoC3vtmHKZmyomGzChAkTJkwHMs2O8E2xNYFuB3rasKNtxGLChAkTptOZ8iBgVhrOlzsLCNogI/++iJ4wYcKECdPbM+238RWJZZvW3lWAxoQJEyZM35Np///tMXzvK8mbmrdl0pgwYcKE6XCmtpE5KwrPwpQ6ucWECRMmTI9mykuo7SF972/bQZyW7/IFY8KECROmY5k2xdZZ4tpytM3I9imbojAmTJgwYXpjpp+kgm2+vbe3vAAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/JDK%E6%BA%90%E7%A0%81-AQS/">JDK源码 AQS</a></div><div class="post-nav"><a class="next" href="/2020/02/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/">数组的定义</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC80ODc5NC8yNTI4OA"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK%E6%BA%90%E7%A0%81/">JDK源码</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/" style="font-size: 15px;">数据结构 数组</a> <a href="/tags/JDK%E6%BA%90%E7%A0%81-AQS/" style="font-size: 15px;">JDK源码 AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/%E6%8A%80%E6%9C%AF/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/jdk%E6%BA%90%E7%A0%81/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">AQS源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/">数组的定义</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/zzsymyos" title="github" target="_blank">github</a><ul></ul><a href="https://leetcode-cn.com/" title="leetcode" target="_blank">leetcode</a><ul></ul><a href="https://github.com/Kaiyuan/sponsor-page" title="sponsor" target="_blank">sponsor</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">兔子临死前.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.3" async></script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.3"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.3"></script></div></body></html>